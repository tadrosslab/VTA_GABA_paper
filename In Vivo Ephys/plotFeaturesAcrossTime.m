%Written 12/2023 by MRT
%Cleaned up and commented 3/2024 by SB
% MIT License
% Copyright (c) 2024 Michael R. Tadross

%Function to plot how firing features change across the course of the ephys
%recording
%Instructions:
%   Use premade allCells data structures generated by spikingAcrossCells
%   output: plots of ddHTP vs HTP for all features of interest

function plotFeaturesAcrossTime()

%load allCells files generated by spikingAcrossCells
Files = {'ddHTP final_grouped spiking analysis_n18.mat'  'HTP final_grouped spiking analysis_n39.mat'};
Color = {[0 0 0]  [202 61 150]/255};
set(0,'DefaultFigureWindowStyle','docked');

%1 is control ddHTP, 2 is +HTP
for W=1:2
    load(Files{W});
    WindowWidth = 900;  %900 sec = 15 minute (window width)
    WindowStart = 0:(3*60):(7200-WindowWidth);  %sliding start of the window
    %initialize variables
    dat = [];
    dat.FR = [];
    dat.percentPSI = [];
    dat.percentSFB = [];
    dat.mISI = [];
    dat.lenPause = [];
    dat.spikePerBurst = [];
    
    %go through each cell
    for i = 1:length(allCells)
        %calculate the below features for each window in the sliding window
        for x = 1:length(WindowStart)
            currSpikeTimesSec = allCells(i).spikeTimesSec(allCells(i).spikeTimesSec > WindowStart(x) & allCells(i).spikeTimesSec < WindowStart(x)+WindowWidth);
            
            %--Tonic firing rate--
            try
                tonicFR = length(currSpikeTimesSec)/WindowWidth;
            catch
                tonicFR = 0; %if can't calculate tonicFR, no spikes and therefore 0
            end
            dat.FR(i, x) = tonicFR;
            
            %--ISI--
            fullISI = diff(currSpikeTimesSec);  %vector of ISI for this 900 sec window
            fullISI = rmmissing(fullISI);  %this omits nan
            dat.mISI(i, x) = median(fullISI);  %tonic ISI = median ISI
            
            %--Bursts--
            %Burst: 3-10 spikes of decreasing amplitude, started by an ISI of <80ms and ended by a >160ms ISI
            Burst_ISI_Thresh_Sec = [.08 0.16];
            fullBurstLen = []; %initialize
            TMP = 0;  %temporary variable to count the number of ISI in this burst
            for b=1:length(fullISI)
                %if a burst has not started yet
                if TMP == 0 
                    %check if we meet the more stringent criteria of start of a burst
                    if fullISI(b) <= Burst_ISI_Thresh_Sec(1)  
                        TMP = TMP + 1;
                    end
                else
                    %we are already in a burst, so criteria is easier
                    if fullISI(b)<= Burst_ISI_Thresh_Sec(2)  
                        TMP = TMP + 1;
                    else %as soon as we have an ISI > 160ms, save burst length and reset
                        fullBurstLen(end+1) = TMP+1; %add 1 - because this is the count of ISIs, we need to consider an additional "ending" spike as within the burst
                        TMP = 0;
                    end
                end
            end           
            fullBurstLen = fullBurstLen(fullBurstLen>2);%must have 3 spikes or more to be considered a burst
            dat.percentSFB(i, x) = sum(fullBurstLen)/(length(fullISI)+1); %percentSFB = percentage of spikes within spike train fired in bursts
            dat.spikePerBurst(i, x) = mean(fullBurstLen); %median spikes per burst
            
            %--Pauses--
            %reduction in activity beyond average for this window. ISI > tonic ISI
            pause_thresh = dat.mISI(i, x)*2;   %Threshold is the median ISI for each bin
            fullPauses = fullISI(fullISI > pause_thresh);  %MRT simpler code
            
            dat.percentPSI(i, x) = length(fullPauses)/length(fullISI);
            dat.lenPause(i, x) = mean(fullPauses)/dat.mISI(i, x);
        end
    end
    
    %---PLOTTING CODE---
    x = WindowStart/60 - 30; 
    
    Fld = fieldnames(dat);
    for f=1:length(Fld)
        subplot(2,3,f); if W==1, cla; end; hold on;
        XL = [x(1)-5  x(end)+5];
        plot(XL,[0 0], 'k');
        
        %calculate the delta-Norm to the baseline value
        FieldData = dat.(Fld{f}); %FR, percentSFB, etc   --  this is [#Cells x #timepoints]
        FieldDeltaNorm = FieldData*0;  %initialize
        for i = 1:size(FieldData, 1)  %for each cell
            Numerator   = (FieldData(i, :)-FieldData(i,1)); %post minus baseline
            Denominator = (FieldData(i, :)+FieldData(i,1)); %post plus baseline
            FieldDeltaNorm(i, :) = (FieldData(i, :)-FieldData(i, 1)) ./ (FieldData(i, :)+FieldData(i,1)); %delta-norm calculation: post minus baseline / post plus baseline
            FieldDeltaNorm(i,Numerator==0 & Denominator==0) = 0;
            if any(isnan(FieldDeltaNorm(i,:)))
                %attempt to interpolate NaNs
                FieldDeltaNorm(i,:) = fillmissing(FieldDeltaNorm(i,:),'linear');
            end
        end
        
        MEAN = mean(FieldDeltaNorm, 'omitnan');
        SEM = std(FieldDeltaNorm, 'omitnan')/sqrt(length(allCells));
        SHADING = [MEAN + SEM; MEAN - SEM];
        %plot
        plot(x, MEAN, 'linewidth', 2, 'Color', Color{W});
        eh2 = patch([x fliplr(x)], [SHADING(1, :) fliplr(SHADING(2, :))], Color{W}, 'EdgeColor', 'none');
        set(eh2, 'facealpha', .3);
        %fill in graph details
        set(gca,'xtick',[-30:15:75]);
        ylim([-0.28 0.19]);  
        xlim(XL);        
        xlabel('Time (min)');
        ylabel(['delta ' Fld{f} '_{norm}']);
        grid on;
        
        set(gca,'fontsize',16);
        drawnow;
    end
    
end
